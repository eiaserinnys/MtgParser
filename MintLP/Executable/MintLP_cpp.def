//////////////////////////////////////////////////////////////////////////////////
//                                                      Mint Virtual Machine Win32
//                                : this file is automatically generated by MintLP
//
//                                       eias erinys fecit, begins at 2002. 10. 19
//                                          eias@nexon.co.kr, sheplany@nownuri.net
//////////////////////////////////////////////////////////////// component of Mint

@@(PRECOMPILEDHEADER)

#include <Text/StringBuilder.h>
#include <IO/Compression/Zip.h>
@@(INCLUDE)

// 코드가 낡았기 때문에 워닝이 많이 발생한다.
// 자동 생성한 코드기 때문에 문제를 일으킬 여지는 없으므로 모두 비활성화시킨다

// warning C4100: '~' : 참조되지 않은 형식 매개 변수입니다.
#pragma warning(disable:4100)

// warning C4245: '초기화 중' : '~'에서 '~'(으)로의 변환입니다. signed 또는 unsigned가 일치하지 않습니다.
#pragma warning(disable:4245)

#include "@(FILENAME).h"

#define mtc(x)		x

using namespace std;
//#ifndef _STLPORT_VERSION
//using namespace stdext;
//#endif

using namespace Core;

@@(DEFINE)
//////////////////////////////////////////////////////////////////////////////////
// statics

// lexer
bool					@(LEXERCLASS)::ms_bReady;
static hash_map<
	unsigned, unsigned>			gs_cLexerFinalStateMap;
@@@(PARSERSTATICDEF)

typedef CParser::parsed*	LPPARSED;
typedef CParser::evaluated*	LPEVALUATED;

// parsed token position evaluation macro
#define get_col_row(x)														\
{																			\
	unsigned i = 0;																\
	___pRet->dwCol = 0xffffffff;											\
	while (___pRet->dwCol == 0xffffffff && i < (x)) {						\
		___pRet->Set(___pInfo[i]->dwCol, ___pInfo[i]->dwRow, _T(""), 0);	\
		i++;																\
	}																		\
}

inline unsigned __int64& set_u64_low(unsigned __int64& _qwValue, unsigned long _dwLow)
{
	*((unsigned long*) &_qwValue) = _dwLow;
	return _qwValue;
}
inline unsigned __int64& set_u64_high(unsigned __int64& _qwValue, unsigned long _dwHigh)
{
	(*(((unsigned long*) &_qwValue) + 1)) = _dwHigh;
	return _qwValue;
}

// parser
typedef hash_map<
	unsigned __int64, SParserMove>	CParsingTable;
	
bool					@(PARSERCLASS)::ms_bReady;
static CParsingTable	gs_cParserMoveMap;
@@@(/PARSERSTATICDEF)
@@(PARSERSTATIC)

//////////////////////////////////////////////////////////////////////////////////
unsigned @(LEXERCLASS)::GetStateNo() const
// : get state no of the DFA
//////////////////////////////////////////////////////////////////////////////////
{
	return state_no;
}

//////////////////////////////////////////////////////////////////////////////////
void @(LEXERCLASS)::Ready() const
// : ready to lexing
//////////////////////////////////////////////////////////////////////////////////
{

	if (!ms_bReady)
	{
		int compressedSize, i;

		// decompress the transition table
		compressedSize = transition_table_size * sizeof(unsigned);
		Zip::Uncompress(
			ms_pTransitionTable, 
			compressedSize, 
			ms_pCompressedTransitionTable, 
			compressed_transition_table_size);

		assert(
			("@(LEXERCLASS)::Ready() : table size does not match", 
			compressedSize == transition_table_size * sizeof(unsigned)));
			
		// build final state map
		for (i = 0; i < final_state_no; ++i)
		{
			gs_cLexerFinalStateMap.insert(
				hash_map<unsigned, unsigned>::value_type(
					ms_pFinalState[i].dwState, ms_pFinalState[i].dwOutput));
		}
		
		// now it is ready
		ms_bReady = true;
	}
}
		
//////////////////////////////////////////////////////////////////////////////////
const unsigned*
	@(LEXERCLASS)::GetTranstionTable() const
// : get DFA transition table
//////////////////////////////////////////////////////////////////////////////////
{
	if (!ms_bReady)	{	Ready();	}

	return ms_pTransitionTable;
}

//////////////////////////////////////////////////////////////////////////////////
const TCHAR* @(LEXERCLASS)::GetTokenName(
	unsigned _dwTokenId) const
// token name query
//////////////////////////////////////////////////////////////////////////////////
{
	if (_dwTokenId < token_no)
	{
		return ms_pTokenName[_dwTokenId];
	}

	// no name for error token
	return NULL;
}

//////////////////////////////////////////////////////////////////////////////////
bool @(LEXERCLASS)::IsFinalState(
	unsigned _dwState,					// in)		state no
	unsigned& _dwOutput) const			// out)		state output if it is a final
// : is it a final state?
//////////////////////////////////////////////////////////////////////////////////
{
	hash_map<unsigned, unsigned>::iterator	fit;
	
	if (!ms_bReady)	{	Ready();	}
	
	fit = gs_cLexerFinalStateMap.find(_dwState);
	
	if (fit != gs_cLexerFinalStateMap.end())
	{
		_dwOutput = (*fit).second;
		return true;
	}
	
	return false;
}

//////////////////////////////////////////////////////////////////////////////////
bool @(LEXERCLASS)::IsTokenToIgnore(
	unsigned _dwTokenId) const			// in)		token id
//: is a token to ignore
//////////////////////////////////////////////////////////////////////////////////
{
	if (_dwTokenId < token_no)
	{
		return ms_pIgnoreOutput[_dwTokenId];
	}

	// we cannot ignore error token
	return false;
}

//////////////////////////////////////////////////////////////////////////////////
void @(LEXERCLASS)::Modify(
	CLexerFrom* _pLexer, 			// in)		lexer class
	unsigned _dwTokenId, 				// in)		token id
	const Core::String& _strTextIn,		// in)		text to modify
	Core::String& _strTextOut,			// out)		text modified
	unsigned _dwRow, unsigned _dwCol)		// in)		position of the token
// : modification
//////////////////////////////////////////////////////////////////////////////////
{
	_strTextOut = _strTextIn;

	#undef LEXER
	#undef NEWLINE
	#undef NEXTROW
	#undef NEXTCOL
	#undef TOKEN_ROW
	#undef TOKEN_COL
	#undef TOKEN_TEXT
	#undef RETURN

	#define LEXER()			(*_pLexer)
	#define NEWLINE()		(_pLexer->NewRow())
	#define NEXTROW()		(_pLexer->NewRow())
	#define NEXTCOL()		(_pLexer->NewCol())
	#define TOKEN_COL()		(_dwCol)
	#define TOKEN_ROW()		(_dwRow)
	#define TOKEN_TEXT()	(_strTextIn)
	#define RETURN()		(_strTextOut)
	@@@(LEXERMODIFYBLOCKDEF)
	
	switch (_dwTokenId) {
	@@(LEXERMODIFYSWITCH)
	};
	@@@(/LEXERMODIFYBLOCKDEF)
	@@(LEXERMODIFYBLOCK)

	#undef LEXER
	#undef NEWLINE
	#undef NEXTROW
	#undef NEXTCOL
	#undef TOKEN_ROW
	#undef TOKEN_COL
	#undef TOKEN_TEXT
	#undef RETURN
};

//////////////////////////////////////////////////////////////////////////////////
bool @(LEXERCLASS)::GetValue(
	unsigned _dwTokenId, 				// in)		token id
	const Core::String& _strText, 		// in)		token text
	void*& _pValue)	const			// out)		value to return
// : get token value
//////////////////////////////////////////////////////////////////////////////////
{
	#undef RETURN
	#undef TOKEN_TEXT

	#define RETURN(_x)			(_pValue = (void*) (_x), bRet = true)
	#define TOKEN_TEXT()		(_strText)

	bool bRet;

	bRet	= false;
	_pValue	= NULL;
	@@@(LEXERVALUEBLOCKDEF)
	
	switch (_dwTokenId) {
	@@(LEXERVALUESWITCH)
	};
	@@@(/LEXERVALUEBLOCKDEF)
	@@(LEXERVALUEBLOCK)

	return bRet;

	#undef RETURN
	#undef TOKEN_TEXT
}

//////////////////////////////////////////////////////////////////////////////////
unsigned @(LEXERCLASS)::GetFinalOutput(
	unsigned _dwTokenId) const			// in/out)	token id
// : get token value
//////////////////////////////////////////////////////////////////////////////////
{
	@@@(LEXERFINALOUTPUTBLOCKDEF)
	switch (_dwTokenId) {
	@@(LEXERFINALOUTPUTSWITCH)
	};
	
	@@@(/LEXERFINALOUTPUTBLOCKDEF)
	@@(LEXERFINALOUTPUTBLOCK)
	return _dwTokenId;
}
@@@(PARSERFUNCTIONDEF)

//////////////////////////////////////////////////////////////////////////////////
void @(PARSERCLASS)::Ready() const
// : ready to parse
//////////////////////////////////////////////////////////////////////////////////
{

	if (!ms_bReady)
	{
		vector<SParserMoveEx>	cDecompressed;
		int						compressedSize, i;
		
		// ready buffer to decompress
		cDecompressed.resize(parsing_table_size);

		// decompress the parsing table
		compressedSize = parsing_table_size * sizeof(SParserMoveEx);
		Zip::Uncompress(
			&cDecompressed[0], 
			compressedSize, 
			ms_pCompressedParsingTable, 
			compressed_parsing_table_size);

		assert(
			("@(PARSERCLASS)::Ready() : table size does not match", 
			compressedSize == parsing_table_size * sizeof(SParserMoveEx)));
			
		// build parsing table
		// (because it is sparse matrix, we should make it a stdext::hash_map)
		for (i = 0; i < parsing_table_size; ++i)
		{
			unsigned __int64			qwKey;
			SParserMove		sMove;
			SParserMoveEx&	sMoveEx = cDecompressed[i];
			
			sMove.eMove		= sMoveEx.eMove;
			sMove.dwArg[0]	= sMoveEx.dwArg[0];
			sMove.dwArg[1]	= sMoveEx.dwArg[1];

			set_u64_high(qwKey, sMoveEx.dwState);
			set_u64_low(qwKey, sMoveEx.dwSymbol);

			gs_cParserMoveMap.insert(
				CParsingTable::value_type(qwKey, sMove));
		}
		
		// now it is ready
		ms_bReady = true;
	}
}

//////////////////////////////////////////////////////////////////////////////////
const Core::String @(PARSERCLASS)::Error(
	unsigned _dwRow, 					// in)		token row
	unsigned _dwCol, 					// in)		token col
	const Core::String& _strType, 		// in)		token typename
	const Core::String& _strText)		// in)		token text
// : process error
//////////////////////////////////////////////////////////////////////////////////
{
	#define RETURN(x)		(strReturn$ = (x))
	#define COL()			_dwCol
	#define ROW()			_dwRow
	#define SYMBOL_TEXT()	(_strText.c_str())
	#define SYMBOL_TYPE()	(_strType.c_str())

	Core::String	strReturn$;
	
	strReturn$ = StringBuilder::Format(
	_T("error ({0:d}, {1:d}) : token {2:s} ({3:s}) is not expected here\n"),
		ROW(), COL(), SYMBOL_TEXT(), SYMBOL_TYPE());
	@@(PARSERERROR)

	#undef RETURN
	#undef COL
	#undef ROW
	#undef SYMBOL_TEXT
	#undef SYMBOL_TYPE

	return strReturn$;
}

//////////////////////////////////////////////////////////////////////////////////
unsigned @(PARSERCLASS)::GetParserSymbolIdFromLexerItemId(
	unsigned _dwItemId) const
// : query
//////////////////////////////////////////////////////////////////////////////////
{
	if (_dwItemId < @(LEXERCLASS)::token_no)
	{
		return ms_pItemToSymbolTable[_dwItemId];
	}
	return saInvalid;
}

//////////////////////////////////////////////////////////////////////////////////
EParserMove
	@(PARSERCLASS)::GetMove(
		unsigned _dwStateNo, 			// in)		state no
		unsigned _dwSymbolNo,			// in)		symbol no
		unsigned& _dwArgument) const	// out)		move argument
// : query parsing table
//////////////////////////////////////////////////////////////////////////////////
{
	if (!ms_bReady)		{	Ready();	}

	CParsingTable::iterator	tit;
	unsigned __int64					qwKey;

	// make key
	set_u64_high(qwKey, _dwStateNo);
	set_u64_low(qwKey, _dwSymbolNo);

	// find transition
	tit = gs_cParserMoveMap.find(qwKey);
	
	if (tit != gs_cParserMoveMap.end())
	{
		SParserMove& sMove = (*tit).second;
		_dwArgument = sMove.dwArg[0];
		return sMove.eMove;
	}
	return pmError;
}

//////////////////////////////////////////////////////////////////////////////////
unsigned @(PARSERCLASS)::GetStateNo() const
// : get no of terminals
//////////////////////////////////////////////////////////////////////////////////
{
	return state_no;
}

//////////////////////////////////////////////////////////////////////////////////
unsigned @(PARSERCLASS)::GetTerminalNo() const
// : get no of terminals
//////////////////////////////////////////////////////////////////////////////////
{
	return terminal_no;
}

//////////////////////////////////////////////////////////////////////////////////
unsigned @(PARSERCLASS)::GetNonTerminalNo() const
// : get no of terminals
//////////////////////////////////////////////////////////////////////////////////
{
	return non_terminal_no;
}

//////////////////////////////////////////////////////////////////////////////////
unsigned @(PARSERCLASS)::GetTerminatorId() const
// : get no of terminals
//////////////////////////////////////////////////////////////////////////////////
{
	return (unsigned) terminator_id;
}

//////////////////////////////////////////////////////////////////////////////////
const parser_rule* @(PARSERCLASS)::GetRule(
	unsigned& _dwRuleNo,				// in)		no of rules
	unsigned& _dwMaxRuleLength) const	// in)		maximum length of the rules
// : get rule
//////////////////////////////////////////////////////////////////////////////////
{
	_dwRuleNo = rule_no;
	_dwMaxRuleLength = rule_max_length;
	return ms_pRule;
}

//////////////////////////////////////////////////////////////////////////////////
LPEVALUATED @(PARSERCLASS)::EvaluateTerminal(
	CParser* _pParser,				// in)		parser
	LPPARSED _pParsed)				// in)		parsed result
// : evaluate terminal
//////////////////////////////////////////////////////////////////////////////////
{
	LPEVALUATED pRet = _pParser->NewEvaluated(1);
	pRet->Set(
		_pParsed->GetCol(), _pParsed->GetRow(),
		_pParsed->GetText(), _pParsed->GetValue());
	return pRet;
}

//////////////////////////////////////////////////////////////////////////////////
// macro for parsed evaluation
#define RETURN(x)		(___pRet->pValue = (void*) (x))
#define SYM(x)			((const Core::String&) ___pInfo[(x)]->strText)
#define VAL(x)			(___pInfo[(x)]->pValue)
#define COL(x)			(___pInfo[(x)]->dwCol)
#define ROW(x)			(___pInfo[(x)]->dwRow)
#define FILE()			(_pParser->GetFileName())
//////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////
void* @(PARSERCLASS)::Evaluate(
	CParser* _pParser,
	void* _pParsed)
// : evaluate parsed AST
//////////////////////////////////////////////////////////////////////////////////
{
	LPPARSED		pParsed		= (CParser::parsed*) _pParsed;
	LPEVALUATED		pInfo		= NULL;
	void*			pValue		= NULL;
	unsigned			dwSymbol	= pParsed->GetSymbol();

	switch(dwSymbol) {
	@@(PARSERMAINEVALUATELIST)
	};

	pValue = pInfo->pValue;
	_pParser->DeleteEvaluated(pInfo);

	return pValue;
}
@@(PARSEREVALUATEFUNCTIONLIST)
@@@(/PARSERFUNCTIONDEF)
@@@(PARSERMAINEVALUATENTDEF)
case @(PARSERSYMBOLNO): pInfo = Evaluate_@(PARSEREVALUATENAME)(_pParser, pParsed); break;
@@@(/PARSERMAINEVALUATENTDEF)
@@@(PARSERMAINEVALUATETDEF)
case @(PARSERSYMBOLNO): pInfo = EvaluateTerminal(_pParser, pParsed); break;
@@@(/PARSERMAINEVALUATETDEF)
@@@(PARSERERRORDEF)

{
	@@(PARSERERRORSCRIPT)
}
@@@(/PARSERERRORDEF)
@@@(PARSEREVALUATEFUNCTIONDEF)

//////////////////////////////////////////////////////////////////////////////////
LPEVALUATED @(PARSERCLASS)::Evaluate_@(PARSEREVALUATENAME)(
	CParser* _pParser, LPPARSED _pParsed)
// : evaluate non-terminal @(PARSEREVALUATENAME)
//////////////////////////////////////////////////////////////////////////////////
{
	unsigned dwRule = _pParsed->GetRule();

	LPEVALUATED ___pRet = _pParser->NewEvaluated(1);

	switch(dwRule) {
	@@(PARSEREVALUATECASE)
	};

	return ___pRet;
}
@@@(/PARSEREVALUATEFUNCTIONDEF)
@@@(PARSEREVALUATECASEDEF)
case @(PARSERRULE):
	{	// @(PARSERRULEDUMP)
		LPEVALUATED* ___pInfo = 
			(LPEVALUATED*) malloc(sizeof(LPEVALUATED) * @(PARSEREVALUATENO));
		@@(PARSEREVALUATEEACH)
		get_col_row(@(PARSEREVALUATENO));

		@@(PARSEREVALUATESCRIPT)
		@@(PARSEREVALUATEDELETE)
		free(___pInfo);

		return ___pRet;
	}
@@@(/PARSEREVALUATECASEDEF)
@@@(PARSEREVALUATENULLCASEDEF)
case @(PARSERRULE):
	{	// @(PARSERRULEDUMP)
		@@(PARSEREVALUATESCRIPT)
		return ___pRet;
	}
@@@(/PARSEREVALUATENULLCASEDEF))
@@@(PARSEREVALUATENTDEF)
___pInfo[@(PARSEREVALUATENO)] = Evaluate_@(PARSEREVALUATENAME)(_pParser, (*_pParsed)[@(PARSEREVALUATENO)]);
@@@(/PARSEREVALUATNTDEF)
@@@(PARSEREVALUATETDEF)
___pInfo[@(PARSEREVALUATENO)] = EvaluateTerminal(_pParser, (*_pParsed)[@(PARSEREVALUATENO)]);
@@@(/PARSEREVALUATTDEF)
@@@(PARSEREVALUATEDELETEDEF)
_pParser->DeleteEvaluated(___pInfo[@(PARSEREVALUATENO)]);
@@@(/PARSEREVALUATEDELETEDEF)
@@@(PARSEREVALUATEUSERSCRIPTDEF)
// user code begin
@@(PARSEREVALUATESCRIPT)
// user code end

@@@(/PARSEREVALUATEUSERSCRIPTDEF)
@@(PARSERFUNCTION)

//////////////////////////////////////////////////////////////////////////////////
// lexer DFA transition table
unsigned @(LEXERCLASS)::
	ms_pTransitionTable[@(LEXERCLASS)::transition_table_size];

// zlib-compressed DFA table (DO NOT EDIT)
const unsigned char @(LEXERCLASS)::
	ms_pCompressedTransitionTable[@(LEXERCLASS)::compressed_transition_table_size] =
{
	@@(COMPRESSEDLEXERTABLE)
};

// final state table (DO NOT EDIT)
const lexer_desc::final_state @(LEXERCLASS)::
	ms_pFinalState[@(LEXERCLASS)::final_state_no] = 
{
	@@(LEXERFINALSTATETABLE)
};

// ignore tokens (DO NOT EDIT)
const bool @(LEXERCLASS)::
	ms_pIgnoreOutput[@(LEXERCLASS)::token_no] = 
{
	@@(LEXERIGNORELIST)
};

// token name
const TCHAR* @(LEXERCLASS)::
	ms_pTokenName[@(LEXERCLASS)::token_no] =
{
	@@(LEXERITEMNAMELIST)
};
@@@(PARSERTABLEDEF)

//////////////////////////////////////////////////////////////////////////////////
// zlib-compressed parsing table (DO NOT EDIT)
const unsigned char @(PARSERCLASS)::
	ms_pCompressedParsingTable[@(PARSERCLASS)::compressed_parsing_table_size] =
{
	@@(COMPRESSEDPARSERTABLE)
};

// parser symbol names
const char* @(PARSERCLASS)::
	ms_pSymbolName[@(PARSERCLASS)::terminal_no + @(PARSERCLASS)::non_terminal_no] = 
{
	@@(PARSERSYMBOLNAMELIST)
};

// parsing rules
const unsigned @(PARSERCLASS)::
	ms_pTotalRule[@(PARSERCLASS)::rule_total_length] = 
{
	@@(PARSERTOTALRULE)
};

// remapped parsing rules
const parser_rule @(PARSERCLASS)::
	ms_pRule[@(PARSERCLASS)::rule_no] =
{
	@@(PARSERRULELIST)
};

// lexer item id to parser symbol table (DO NOT EDIT)
const unsigned @(PARSERCLASS)::
	ms_pItemToSymbolTable[@(LEXERCLASS)::token_no] = 
{
	@@(PARSERIDTOSYMBOLTABLE)
};
@@@(/PARSERTABLEDEF)
@@@(PARSERRULELISTDEF)
{ ms_pTotalRule + @(PARSERRULEOFFSET), @(PARSERRULELENGTH) }, 
@@@(/PARSERRULELISTDEF)
@@(PARSERTABLE)

//////////////////////////////////////////////////////////////////////////////////
// end of dump
//////////////////////////////////////////////////////////////////////////////////

@@@(CASEBLOCK)
case @(CASE):
	{
		@@(CASESCRIPT)
	}
	break;
@@@(/CASEBLOCK)

