//////////////////////////////////////////////////////////////////////////////////
//                                                      Mint Virtual Machine Win32
//                                : this file is automatically generated by MintLP
//
//                                       eias erinys fecit, begins at 2002. 10. 19
//                                          eias@nexon.co.kr, sheplany@nownuri.net
//////////////////////////////////////////////////////////////// component of Mint

#ifndef __@(TABLEMD5)__
#define __@(TABLEMD5)__

#pragma once		// vc specific

#include <Script/MintLP/MintLexer.h>
#include <Script/MintLP/MintLexerFrom.h>
#include <Script/MintLP/MintParser.h>

// SGI based STL library needed
// (you can use STLPort, www.STLPort.org)
#include <hash_map>

	@@@(LEXERBLOCKDEF)
	//////////////////////////////////////////////////////////////////////////////
	// lexer table definition
	class @(LEXERCLASS) : public lexer_desc {
	public:
		// constants
		enum EItem
		{
			@@(LEXERITEMLIST)
		};

		static const unsigned		state_no = @(LEXERSTATENO);
		static const unsigned		final_state_no = @(LEXERFINALSTATENO);
		static const unsigned		token_no = @(LEXERTOKENNO);
		static const unsigned		transition_table_size = @(LEXERTABLESIZE);
		static const unsigned		compressed_transition_table_size = @(COMPRESSEDLEXERTABLESIZE);
		
	private:
		//------------------------------------------------------------------------
		// interval variables
		
		// is it ready to be used?
		static bool					ms_bReady;

		// transition table
		static unsigned				ms_pTransitionTable[];
		static const unsigned char	ms_pCompressedTransitionTable[];
		
		// final state table
		static const final_state	ms_pFinalState[];
		
		// ignore table
		static const bool			ms_pIgnoreOutput[];
		
		// token name table
		static const TCHAR*			ms_pTokenName[];
		
	private:
		//------------------------------------------------------------------------
		// initialization function
		void						Ready() const;

	public:
		//------------------------------------------------------------------------
		// DFA query
		
		// get no of states in DFA
		unsigned					GetStateNo() const;
		
		// DFA transition table
		const unsigned*				GetTranstionTable() const;

		// token name query
		const TCHAR*				GetTokenName(unsigned _dwTokenId) const;

		// final state query
		bool						IsFinalState(
										unsigned _dwState,	
										unsigned& _dwOutput) const;

		// check if this token is to ignore in parsing
		bool						IsTokenToIgnore(
										unsigned _dwTokenId) const;

		// token modification
		void						Modify(
										CLexerFrom* _pLexer, 
										unsigned _dwTokenId, 
										const Core::String& _strTextIn, 
										Core::String& _strTextOut, 
										unsigned _dwRow, unsigned _dwCol);

		// token value query
		bool						GetValue(
										unsigned _dwTokenId, 
										const Core::String& _strText, 
										void*& _pValue) const;

		// group token value modification
		unsigned					GetFinalOutput(unsigned _dwOutput) const;
	};
	@@@(/LEXERBLOCKDEF)
	@@(LEXERBLOCK)
	@@@(PARSERBLOCKDEF)
	
	//////////////////////////////////////////////////////////////////////////////
	// parser table definition
	class @(PARSERCLASS) : public parser_desc {
	public:
		// constants
		enum ESymbol
		{
			@@(PARSERSYMBOLLIST)
		};

		static const unsigned		rule_no = @(PARSERRULENO);
		static const unsigned		rule_total_length = @(PARSERRULETOTALLENGTH);
		static const unsigned		rule_max_length = @(PARSERRULEMAXLENGTH);
		static const unsigned		state_no = @(PARSERSTATENO);
		static const unsigned		terminal_no = @(PARSERTERMINALNO);
		static const unsigned		non_terminal_no = @(PARSERNONTERMINALNO);
		static const unsigned		terminator_id = @(PARSERTERMINATOR);
		static const unsigned		parsing_table_size = @(PARSERTABLESIZE);
		static const unsigned		compressed_parsing_table_size = @(COMPRESSEDPARSERTABLESIZE);
	
	private:
		//------------------------------------------------------------------------
		// interval variables
		
		// is it ready to be used?
		static bool					ms_bReady;
	
		// symbol name table
		static const char*			ms_pSymbolName[];

		// total rules
		static const unsigned		ms_pTotalRule[];

		// rule table
		static const parser_rule	ms_pRule[];
		
		// lexer item id to parser symbol table
		static const unsigned		ms_pItemToSymbolTable[];

		// parsing table
		static const unsigned char		ms_pCompressedParsingTable[];
		
	private:
		//------------------------------------------------------------------------
		// initialization function
		void						Ready() const;

	public:
		//------------------------------------------------------------------------
		// error processing
		const Core::String			Error(
										unsigned _dwRow, 
										unsigned _dwCol, 
										const Core::String& _strType, 
										const Core::String& _strText);

		// symbol query
		unsigned					GetParserSymbolIdFromLexerItemId(
										unsigned _dwItemId) const;

		// query movement
		EParserMove			GetMove(
										unsigned _dwStateNo, 
										unsigned _dwSymbolNo,
										unsigned& _dwArgument) const;
										
		// some constants
		unsigned					GetStateNo() const;
		unsigned					GetTerminalNo() const;
		unsigned					GetNonTerminalNo() const;
		unsigned					GetTerminatorId() const;
		const parser_rule*			GetRule(
										unsigned& _dwRuleNo,
										unsigned& _dwMaxRuleLength) const;
		
		//------------------------------------------------------------------------
		// evaluate
		void*						Evaluate(CParser*, void*);
		CParser::evaluated*			EvaluateTerminal(CParser*, CParser::parsed*);
		@@(PARSEREVALUATEHEADERLIST)
	};
	@@@(/PARSERBLOCKDEF)
	@@@(PARSEREVALUATEHEADERDEF)
	CParser::evaluated*			Evaluate_@(PARSEREVALUATENAME)(CParser*, CParser::parsed*);
	@@@(/PARSEREVALUATEHEADERDEF)
	@@(PARSERBLOCK)

#endif



