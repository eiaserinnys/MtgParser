//////////////////////////////////////////////////////////////////////////////////
//                                                      Mint Virtual Machine Win32
//                                                                    mint::CLexer
//                                                        : mint lexer engine core
//
//                                        eias erinys fecit, began at 2002. 10. 19
//                                          eias@nexon.co.kr, sheplany@nownuri.net
//////////////////////////////////////////////////////////////// component of Mint

#include "pch.h"
#include <Script/MintLP/MintLexer.h>


//////////////////////////////////////////////////////////////////////////////////
void* lexer_desc::operator new (
	size_t _iSize)
// : new handler
//////////////////////////////////////////////////////////////////////////////////
{
	return ::operator new (_iSize);
}

//////////////////////////////////////////////////////////////////////////////////
void lexer_desc::operator delete (
	void* _pMemory)
// : delete handler
//////////////////////////////////////////////////////////////////////////////////
{
	::operator delete (_pMemory);
}

//////////////////////////////////////////////////////////////////////////////////
CLexer::CLexer() 

	: m_dwCurrentState(0)
	, m_bOpen(false)
	, m_pLexerDesc(NULL)

// : constructor
//////////////////////////////////////////////////////////////////////////////////
{
}

//////////////////////////////////////////////////////////////////////////////////
CLexer::CLexer(
	lexer_desc* _pDesc) 

	: m_dwCurrentState(0)
	, m_bOpen(false)
	, m_pLexerDesc(NULL)

// : constructor
//////////////////////////////////////////////////////////////////////////////////
{
	Open(_pDesc);
}

//////////////////////////////////////////////////////////////////////////////////
CLexer::~CLexer()
// : destructor
//////////////////////////////////////////////////////////////////////////////////
{
	//	소멸자에서 virtual func. 를 호출!, CLexer::Close() 만 호출된다. - jonggn
	Close();
}

//////////////////////////////////////////////////////////////////////////////////
void CLexer::Open(
	lexer_desc* _pDesc)
// : initialize
//////////////////////////////////////////////////////////////////////////////////
{
	assert(("CLexer::Open() : CLexer::End() should be called before", !m_bOpen));
	assert(("CLexer::Open() : lexer descriptor should not be null", _pDesc != NULL));

	m_bOpen				= true;
	m_dwCurrentState	= 0;

	m_pLexerDesc		= _pDesc;
	m_pTransitionTable	= _pDesc->GetTranstionTable();
	m_dwStateNo			= _pDesc->GetStateNo();
}

//////////////////////////////////////////////////////////////////////////////////
bool CLexer::Close()
// : end lexing
//////////////////////////////////////////////////////////////////////////////////
{
	bool bLast = m_bOpen;

	// delete previous descriptor
	delete m_pLexerDesc;

	// reset context
	m_bOpen				= false;
	m_dwCurrentState	= 0;

	// reset lexer desc
	m_pTransitionTable	= NULL;
	m_dwStateNo			= 0;

	return bLast;
}

//////////////////////////////////////////////////////////////////////////////////
void CLexer::InitializeMove()
// : init move
//////////////////////////////////////////////////////////////////////////////////
{
	assert(("CLexer::InitializeMove() : CLexer::Begin() should be called before", m_bOpen));
	m_dwCurrentState = 0;
}

//////////////////////////////////////////////////////////////////////////////////
bool CLexer::Move(
	char _ncMove)
// : move, returns true if it was a valid move
//////////////////////////////////////////////////////////////////////////////////
{
	//bool	bFound	= false;
	unsigned	dwNextState;

	// not opened? then no operation
	if (!m_bOpen)	{	return false;	}

	// get hash value
	if (m_dwCurrentState < m_dwStateNo)
	{
		dwNextState = m_pTransitionTable[
			m_dwCurrentState * 0x100 + (unsigned char) _ncMove];

		if (dwNextState < m_dwStateNo && dwNextState != saInvalid)
		{
			m_dwCurrentState = dwNextState;
			return true;
		}
	}

	return false;
}

//////////////////////////////////////////////////////////////////////////////////
bool CLexer::IsFinal(
	unsigned& _dwOutput)
// : check if it is final state
//////////////////////////////////////////////////////////////////////////////////
{
	if (!m_bOpen)	{	return false;	}

	return m_pLexerDesc->IsFinalState(m_dwCurrentState, _dwOutput);
}


